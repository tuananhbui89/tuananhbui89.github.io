<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Practicing 75 Leetcode Questions - Tree | Tuan-Anh  Bui</title>
    <meta name="author" content="Tuan-Anh  Bui">
    <meta name="description" content="One Leetcode a day keeps unemployment away">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e">
    <link rel="canonical" href="https://tuananhbui89.github.io/projects/project_75_leetcode_questions_tree/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">
    <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script>
    <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Tuan-Anh </span>Bui</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item ">
                <a class="nav-link" href="/blog/">blog</a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">projects</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/repositories/">repositories</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/teaching/">teaching</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Practicing 75 Leetcode Questions - Tree</h1>
    <p class="post-meta">October 27, 2023</p>
    <p class="post-tags">
      <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>
        ·  
        <a href="/blog/category/work">
          <i class="fas fa-tag fa-sm"></i> work</a>  
          

    </p>
  </header>

  <article class="post-content">
    
    <div id="table-of-contents">
      <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#104-maximum-depth-of-binary-tree">104. Maximum Depth of Binary Tree</a></li>
<li class="toc-entry toc-h2"><a href="#100-same-tree">100. Same Tree</a></li>
<li class="toc-entry toc-h2"><a href="#226-invert-binary-tree">226. Invert Binary Tree</a></li>
<li class="toc-entry toc-h2"><a href="#124-binary-tree-maximum-path-sum">124. Binary Tree Maximum Path Sum</a></li>
<li class="toc-entry toc-h2"><a href="#102-binary-tree-level-order-traversal">102. Binary Tree Level Order Traversal</a></li>
<li class="toc-entry toc-h2"><a href="#297-serialize-and-deserialize-binary-tree">297. Serialize and Deserialize Binary Tree</a></li>
<li class="toc-entry toc-h2"><a href="#572-subtree-of-another-tree">572. Subtree of Another Tree</a></li>
<li class="toc-entry toc-h2"><a href="#105-construct-binary-tree-from-preorder-and-inorder-traversal">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li>
<li class="toc-entry toc-h2"><a href="#98-validate-binary-search-tree">98. Validate Binary Search Tree</a></li>
<li class="toc-entry toc-h2"><a href="#230-kth-smallest-element-in-a-bst">230. Kth Smallest Element in a BST</a></li>
<li class="toc-entry toc-h2"><a href="#235-lowest-common-ancestor-of-a-binary-search-tree">235. Lowest Common Ancestor of a Binary Search Tree</a></li>
<li class="toc-entry toc-h2"><a href="#208-implement-trie-prefix-tree">208. Implement Trie (Prefix Tree)</a></li>
<li class="toc-entry toc-h2"><a href="#211-design-add-and-search-words-data-structure">211. Design Add and Search Words Data Structure</a></li>
<li class="toc-entry toc-h2"><a href="#212-word-search-ii">212. Word Search II</a></li>
<li class="toc-entry toc-h2">
<a href="#reflection-binary-tree-problems">Reflection: Binary Tree Problems?</a>
<ul>
<li class="toc-entry toc-h3"><a href="#revisit-tree-traversal-techniques">Revisit: Tree Traversal Techniques</a></li>
<li class="toc-entry toc-h3"><a href="#-revisit-trie-data-structure"> Revisit Trie Data Structure</a></li>
</ul>
</li>
</ul>
    </div>
    <hr>
    
    <div id="markdown-content">
      <p>In this project, I will try to solve 75 Leetcode questions as listed in this <a href="https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU" rel="external nofollow noopener" target="_blank">link</a>. The goal is to solve at least one question per day or until I get a job <img class="emoji" title=":joy:" alt=":joy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png" height="20" width="20">.</p>

<h2 id="104-maximum-depth-of-binary-tree"><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" rel="external nofollow noopener" target="_blank">104. Maximum Depth of Binary Tree</a></h2>

<font size="6"> Description </font>

<p>Given the root of a binary tree, return its maximum depth.</p>

<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [3,9,20,null,null,15,7]
Output: 3
</code></pre></div></div>

<p>Example 2:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,null,2]
Output: 2
</code></pre></div></div>

<font size="6"> Solution </font>

<p>The solution is quite simple. We just need to traverse the tree and count the depth. The depth of a node is the maximum depth of its children plus one. The depth of a leaf node is 1.</p>

<p>In this solution, I use DFS to traverse the tree. The time complexity is O(n) and the space complexity is O(n) (in the worst case, the tree is a linked list).</p>

<blockquote class="block-warning">
  <p><strong>What is DFS?</strong></p>

  <p>DFS stands for Depth First Search. It is a graph traversal algorithm. The idea is to traverse the graph by going as deep as possible, and backtrack when we cannot go further. The DFS algorithm can be implemented using recursion or stack.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">depth</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<font size="6"> Complexity Analysis </font>

<ul>
  <li>Time complexity: O(n) because we need to traverse all the nodes in the tree once.</li>
  <li>Space complexity: O(n) because we need to store the depth of each node in the stack.</li>
  <li>Hidden space complexity: O(h) where h is the height of the tree. This is the space complexity of the recursion stack.</li>
</ul>

<h2 id="100-same-tree"><a href="https://leetcode.com/problems/same-tree/" rel="external nofollow noopener" target="_blank">100. Same Tree</a></h2>

<font size="6"> Description </font>

<p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p>

<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: p = [1,2,3], q = [1,2,3]
Output: true
</code></pre></div></div>

<p>Example 2:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: p = [1,2], q = [1,null,2]
Output: false
</code></pre></div></div>

<p>Example 3:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: p = [1,2,1], q = [1,1,2]
Output: false
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in both trees is in the range [0, 100].</li>
  <li>-10^4 &lt;= Node.val &lt;= 10^4</li>
</ul>

<font size="6"> Solution </font>

<p>The naive idea that comes to my mind is to traverse the two trees simultaneously and compare the value of each node.
But how to traverse the two trees simultaneously. So I use the DFS algorithm to traverse the two trees separately and store the values of the nodes in two lists. Then I compare the two lists.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">q</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="nf">extract</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                <span class="nf">extract</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        
        <span class="n">values_p</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values_q</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nf">extract</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">values_p</span><span class="p">)</span>
        <span class="nf">extract</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">values_q</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">values_p</span> <span class="o">==</span> <span class="n">values_q</span>
</code></pre></div></div>

<font size="6"> Complexity Analysis </font>

<ul>
  <li>Time complexity: O(n) because we need to traverse all the nodes in the tree once.</li>
  <li>Space complexity: O(n) because we need to store the values of all the nodes in the tree. More precisely, O(4n) because we need to store the values of two trees in two lists.</li>
</ul>

<h2 id="226-invert-binary-tree">226. <a href="https://leetcode.com/problems/invert-binary-tree/" rel="external nofollow noopener" target="_blank">Invert Binary Tree</a>
</h2>

<font size="6"> Description </font>

<p>Given the root of a binary tree, invert the tree, and return its root.</p>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
</code></pre></div></div>

<p>Example 2:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [2,1,3]
Output: [2,3,1]
</code></pre></div></div>

<p>Example 3:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = []
Output: []
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in the tree is in the range [0, 100].</li>
  <li>-100 &lt;= Node.val &lt;= 100</li>
</ul>

<font size="6"> Solution </font>

<p>Each <code class="language-plaintext highlighter-rouge">TreeNode</code> in the binary tree is defined as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
</code></pre></div></div>

<p>It contains three attributes: <code class="language-plaintext highlighter-rouge">val</code>, <code class="language-plaintext highlighter-rouge">left</code>, and <code class="language-plaintext highlighter-rouge">right</code>. The <code class="language-plaintext highlighter-rouge">val</code> attribute stores the value of the node. The <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code> attributes store the left and right children of the node, respectively. If the node does not have a left or right child, the corresponding attribute is <code class="language-plaintext highlighter-rouge">None</code>.
A node without children is called a leaf node. A binary tree is a tree in which each node has at most two children.</p>

<p>The idea of the solution is to traverse the tree and swap the left and right children of each node but keep the value of the node unchanged.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
                <span class="nf">swap</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="nf">swap</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="nf">swap</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div>

<p>Explanation:</p>

<ul>
  <li>if the node is None, return None which is the base case of the recursion.</li>
  <li>if the node is not None, swap the left and right children of the node, then recursively swap the left and right children of the left and right children of the node.</li>
  <li>It is interesting that we can swap the left and right children of the node without temporary variables. This is because Python allows us to assign multiple variables at the same time. For example, <code class="language-plaintext highlighter-rouge">a, b = b, a</code> will swap the values of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. This is called tuple unpacking, which is an in-place operation.</li>
  <li>The important step is to recursive step when we call <code class="language-plaintext highlighter-rouge">swap(node.left)</code> and <code class="language-plaintext highlighter-rouge">swap(node.right)</code> to swap the children of the left and right children of the node.</li>
  <li>Because the root node is unchanged, we can return the root node as the output of the function.</li>
</ul>

<blockquote class="block-warning">
  <p><strong>What is in-place operation?</strong></p>

  <p>An in-place operation is an operation that changes the input directly without making a copy. For example, the swap operation <code class="language-plaintext highlighter-rouge">a, b = b, a</code> is an in-place operation because it does not require extra memory to store the result. The operation <code class="language-plaintext highlighter-rouge">a += b</code> is also an in-place operation because it changes the value of <code class="language-plaintext highlighter-rouge">a</code> directly.</p>
</blockquote>

<h2 id="124-binary-tree-maximum-path-sum"><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" rel="external nofollow noopener" target="_blank">124. Binary Tree Maximum Path Sum</a></h2>

<font size="6"> Description </font>

<p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p>

<p>The path sum of a path is the sum of the node’s values in the path.</p>

<p>Given the root of a binary tree, return the maximum path sum of any non-empty path.</p>

<!-- **Clarification**:

- What is non-empty path? It means that the path must contain at least one node.
- Is the path with only one node a valid path? Yes, it is. -->

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.
</code></pre></div></div>

<p>Example 2:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.
</code></pre></div></div>

<p>Example 3:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,-2,3]
Output: 4
Explanation: The optimal path is 3 -&gt; 1 with a path sum of 3 + 1 = 4.
</code></pre></div></div>

<p>Example 4:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [-2,1,3]
Output: 3
Explanation: The optimal path is just the node 3 with a path sum of 3.
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in the tree is in the range [1, 3 * 10^4].</li>
  <li>-1000 &lt;= Node.val &lt;= 1000</li>
</ul>

<font size="6"> Solution </font>

<p>This is a hard-level question that I couldn’t think of a solution at first. Therefore, I tried to explain my thought process as follows with an expectation that I can come up with a solution along the way. Fortunately, it works <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20"> (with the big help of Github Copilot)</p>

<p>Firstly, we need to clarify the problem.</p>

<ul>
  <li>What is non-empty path? It means that the path must contain at least one node.</li>
  <li>Is the path with only one node a valid path? Yes, it is.</li>
</ul>

<p>So the path can be a sub-tree but every node has atmost one child except the root node which can have two children. The path can also be a single node. The path sum is the sum of all nodes in the sub-tree.
However, with this perspective, it is still not clear how to find the optimal sub-tree. Grid search is not a good idea because the number of sub-trees is exponential with respect to the number of nodes in the tree.</p>

<p>Let’s think in the style of a dynamic programming problem. We can define the sub-problem as follows:</p>

<blockquote>
  <p>Given a path and an adjacent node (the node that is connected to the first or the last node in the path), should we add the adjacent node to the path or not?</p>
</blockquote>

<p>There are two scenarios to be considered:</p>

<ul>
  <li>If the node has a positive value.</li>
  <li>If the node has a negative value but its children have positive values and greater than the absolute value of the node.</li>
</ul>

<p>The first scenario is quite straightforward that it is always better to add the adjacent node to the path. The second scenario is a bit tricky because what if adding it and its children to the path does not benefit the path sum but adding it, its children, and its grandchildren to the path does. In this case, adding the node to the path is a good deal because it will benefit the path sum in the future.</p>

<p>Based on the above analysis, we can think about more general scenarios as follows:</p>

<ul>
  <li>If the node has a positive value, add it to the path.</li>
  <li>If the node has a negative value, but the sub-path starting from its children has a positive value and greater than the absolute value of the node, add it to the path.</li>
</ul>

<p>However, this is still not clear enough to get a deployable solution. But the thought process makes me realize an important observation that “each node has its left child’s optimal path sum and right child’s optimal path sum”. The previous approach is left-to-right scanning manner, when we try to add an adjacent node of the left (or right) of the path to the path. What if we consider a “Middle-Out” approach as</p>

<blockquote>
  <p>Given a node, what is the optimal path sum of the sub-tree rooted at the node? In other words, should we connect the node to its left child, right child, or both?</p>
</blockquote>

<p>With this approach, we can define the optimal path sum of the sub-tree rooted at the node as follows:</p>

<ul>
  <li>The value of the node.</li>
  <li>The value of the node plus the optimal path sum of its left child.</li>
  <li>The value of the node plus the optimal path sum of its right child.</li>
</ul>

<p>Finally, we can write the code as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">max_sum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">max_sum</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">max_sum</span> <span class="o">=</span> <span class="o">-</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">max_sum</span>
</code></pre></div></div>

<p>Explanation:</p>

<ul>
  <li>The base case of the recursion is when the node is None, we return 0. It is worth noting that we return 0 instead of None as in previous problems.</li>
  <li>If the node is not None we then recursively call the function on its left and right children to get the optimal path sum of the sub-trees rooted at the left and right children of the node.</li>
  <li>Then the optimal path sum rooted at the node is the maximum of <code class="language-plaintext highlighter-rouge">node.val</code> and <code class="language-plaintext highlighter-rouge">node.val + left</code> and <code class="language-plaintext highlighter-rouge">node.val + right</code>. It is worth noting that we must not consider the value <code class="language-plaintext highlighter-rouge">node.val + left + right</code> even though it might be the maximum. It is because if we consider this value, we will recursively consider a sub-tree in the node’s children as a valid path, which is not correct.</li>
</ul>

<h2 id="102-binary-tree-level-order-traversal"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" rel="external nofollow noopener" target="_blank">102. Binary Tree Level Order Traversal</a></h2>

<font size="6"> Description </font>

<p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
</code></pre></div></div>

<p>Example 2:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1]
Output: [[1]]
</code></pre></div></div>

<p>Example 3:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = []
Output: []
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in the tree is in the range [0, 2000].</li>
  <li>-1000 &lt;= Node.val &lt;= 1000</li>
</ul>

<font size="6"> Solution </font>

<blockquote class="block-warning">
  <p><strong>What is level order traversal?</strong></p>

  <p>The level order traversal of a binary tree is a traversal that visits the nodes level by level.</p>
</blockquote>

<p>The idea of the solution is to traverse the tree and store the nodes in a list of lists. The first list contains the nodes at level 0, the second list contains the nodes at level 1, and so on. Instead of using DFS, we use BFS to traverse the tree.</p>

<blockquote class="block-warning">
  <p><strong>What is BFS?</strong></p>

  <p>BFS stands for Breadth First Search. It is a graph traversal algorithm. The idea is to traverse the graph by going level by level. The BFS algorithm can be implemented using a queue.</p>
</blockquote>

<p>The following code snippet shows how to implement a queue using a list. The queue is a data structure that supports two operations: enqueue and dequeue. The enqueue operation adds an item to the queue. The dequeue operation removes an item from the queue. The first item that is added to the queue is the first item that is removed from the queue. This is called First In First Out (FIFO).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simple implementation of a queue using a list
</span><span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<!-- The following code snippet shows how to implement the BFS algorithm to traverse the tree.

```python
# Simple BFS implementation
def bfs(root):
    queue = Queue()
    queue.enqueue(root)
    while not queue.is_empty():
        node = queue.dequeue()
        print(node.val)
        if node.left is not None:
            queue.enqueue(node.left)
        if node.right is not None:
            queue.enqueue(node.right)
``` -->

<p>Here is the solution to the problem.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">queue</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
                <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">items</span><span class="p">)):</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
                    <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">levels</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">levels</span>
</code></pre></div></div>

<p>Explanation:</p>

<ul>
  <li>The base case is when the root is None, we return an empty list.</li>
  <li>If the root is not None, we then create a queue and enqueue the root to the queue.</li>
  <li>In each level, we iteratively dequeue all the nodes in the queue and append their values to the level list. Then we enqueue the left and right children of the nodes to the queue. The size of the queue is the number of nodes in the current level. The for loop iterates over the nodes in the current level. It is worth noting that we must not use <code class="language-plaintext highlighter-rouge">for node in queue.items</code> because the size of the queue changes when we enqueue the left and right children of the nodes. Instead, we use <code class="language-plaintext highlighter-rouge">for _ in range(len(queue.items))</code> which iterates over the exact number of nodes in the current level.</li>
  <li>The algorithm terminates when the queue is empty. Then we return the levels list.</li>
</ul>

<h2 id="297-serialize-and-deserialize-binary-tree"><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" rel="external nofollow noopener" target="_blank">297. Serialize and Deserialize Binary Tree</a></h2>

<font size="6"> Description </font>

<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>

<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>

<p>Clarification: The input/output format is the same as <a href="https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-" rel="external nofollow noopener" target="_blank">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
</code></pre></div></div>

<p>Example 2:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = []
Output: []
</code></pre></div></div>

<p>Example 3:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1]
Output: [1]
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in the tree is in the range [0, 10^4].</li>
  <li>-1000 &lt;= Node.val &lt;= 1000</li>
</ul>

<font size="6"> Solution </font>

<p>The idea of the solution is to traverse the tree and store the nodes in a list and then reconstruct the tree from the list in the deserializer. I will use both DFS and BFS in the solution.</p>

<p><strong>Reflection</strong>: After solving this problem with BFS (level order traversal) I realized that BFS is a more intuitive approach to traverse the tree because it is level by level, which might be more matched with my intuition (personally), moreover, in the problem’s description, the input is also in the level order format which triggers me to think about BFS first. However the DFS is a more suitable approach to serialize the tree because it is easier to reconstruct the tree from the list of nodes in the DFS order. In the BFS order, we need to keep track of the parent nodes with a queue to reconstruct the tree.</p>

<p><strong>Solution with BFS</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        </span><span class="sh">"""</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
        <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">queue</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">items</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">levels</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">levels</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">level</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">parent_child</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
                        <span class="n">parent_child</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">current_node</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                        <span class="n">parent_child</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
                        <span class="n">parent_child</span> <span class="o">=</span> <span class="n">current_node</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">current_node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">current_node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span>
        

<span class="c1"># Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
</span></code></pre></div></div>

<p>Explanation:</p>

<p>In the serializer, it is the BFS algorithm that is similar to the previous problem. So this explanation is mostly for the deserializer. Let’s consider the following example:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
Encoded: [[1], [2, 3], [None, None, 4, 5]]
</code></pre></div></div>

<p>Let’s go through the deserializer step by step.</p>

<ul>
  <li>The base case is when the data is an empty list, we return None.</li>
  <li>If the data is not an empty list, we then create a root node with the value of the first element in the first level of the data list. The data always starts with the root node.</li>
  <li>
<del>Because it is a binary tree, therefore, each node always have two children (None is also considered as a child) except the leaf nodes. Therefore, it is safe to assume that the length of the data list is: <code class="language-plaintext highlighter-rouge">2^0 + 2^1 + 2^2 + ... + 2^(n-1) = 2^n - 1</code> where <code class="language-plaintext highlighter-rouge">n</code> is the number of levels in the tree. The first level has 1 node, the second level has 2 nodes, the third level has 4 nodes, and so on. In the example, the length of the data list is 7 which is equal to <code class="language-plaintext highlighter-rouge">2^3 - 1</code> where <code class="language-plaintext highlighter-rouge">n = 3</code></del>.</li>
  <li>Revised: The above observation is incorrect <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">. For example, the input <code class="language-plaintext highlighter-rouge">[1,2,null,3,null,4,null,5]</code> is the left-skewed tree with 5 nodes, with level 0 has 1 node (root), level 1 has 2 node (2 and null), level 3 has 2 node (3 and null, which are children of node 2) and so on.</li>
  <li>After creating the root node, we then create a queue to manage which node we are adding the children to. We start by enqueueing the root’s left and right children to the queue. So after this step, we have a tree - to be built - with only the root node and a queue - to manage the parent nodes - with two children of the root node.</li>
  <li>Then we iterate over the data list from the second level to the last level. In each level, we iterate over the nodes in the level. We have the following actions:
    <ul>
      <li>We create a TreeNode with the value of the current node in the data list. If the value is None, we still create a TreeNode with the value of None.</li>
      <li>We dequeue the parent’s children from the queue. It can be the left or right child of the parent node</li>
      <li>We assign the current node to the the dequeued child. If the value of the current node is None, we assign None to the child.</li>
      <li>We enqueue the left and right children of the current node to the queue. If the value of the current node is None, we enqueue two None values instead.</li>
    </ul>
  </li>
</ul>

<!-- 
Let's go through the example step by step.

```markdown
Input: root = [1,2,3,null,null,4,5]
Encoded: [[1], [2, 3], [None, None, 4, 5]]
Iter 1: tree = [1], queue = [1's left child, 1's right child]
Iter 2: node = 2, deque 1's left child, assign 2 to 1's left child, enqueue 2's left and right children. tree = [1, 2], queue = [1's right child, 2's left child, 2's right child]
Iter 3: node = 3, deque 1's right child, assign 3 to 1's right child, enqueue 3's left and right children. tree = [1, 2, 3], queue = [2's left child, 2's right child, 3's left child, 3's right child]
Iter 4: node = None, deque 2's left child, assign None to 2's left child, enqueue 2's left and right children. tree = [1, 2, 3, None], queue = [2's right child, 3's left child, 3's right child, None, None]
Iter 5: node = None, deque 2's right child, assign None to 2's right child, enqueue 3's left and right children. tree = [1, 2, 3, None, None], queue = [3's left child, 3's right child, None, None, None, None]
Iter 6: node = 4, deque 3's left child, assign 4 to 3's left child, enqueue 4's left and right children. tree = [1, 2, 3, None, None, 4], queue = [3's right child, None, None, None, None, 4's left child, 4's right child]
Iter 7: node = 5, deque 3's right child, assign 5 to 3's right child, enqueue 5's left and right children. tree = [1, 2, 3, None, None, 4, 5], queue = [None, None, None, None, 4's left child, 4's right child, 5's left child, 5's right child]
Terminated because the data list is empty.
``` -->

<p><strong>Turn out that the above solution doesn’t work <img class="emoji" title=":joy:" alt=":joy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png" height="20" width="20"><img class="emoji" title=":joy:" alt=":joy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png" height="20" width="20"><img class="emoji" title=":joy:" alt=":joy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png" height="20" width="20"></strong> The reason is that, I misunderstood the problem. The problem requires us to serialize the tree to a string, not a list of lists. So I need to change the solution with the following changes:</p>

<ul>
  <li>The serializer returns a string instead of a list of lists.</li>
  <li>The deserializer takes a string as input instead of a list of lists.</li>
  <li>There is an <code class="language-plaintext highlighter-rouge">index</code> to manage the index of the current node in the data list.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
</span><span class="kn">import</span> <span class="n">math</span>

<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        </span><span class="sh">"""</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="sh">''</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
        <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">queue</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">items</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode

        example: [</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">4</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">5</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">]
        example 2: 
            input = </span><span class="sh">'</span><span class="s">[1,2,null,3,null,4,null,5]</span><span class="sh">'</span><span class="s">
            encoded = [</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">4</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">5</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="s">]
        </span><span class="sh">"""</span>

        <span class="n">data_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data_list</span> <span class="o">==</span> <span class="p">[</span><span class="sh">''</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

            <span class="n">num_levels</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># to manage index of children in data_list
</span>
            <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">):</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
                <span class="n">left_child</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span> <span class="k">if</span> <span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span> <span class="k">else</span> <span class="bp">None</span>
                <span class="n">right_child</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="k">if</span> <span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span> <span class="k">else</span> <span class="bp">None</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">2</span> 
                <span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left_child</span>
                <span class="n">parent</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right_child</span>
                <span class="k">if</span> <span class="n">left_child</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">left_child</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">right_child</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">right_child</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span>

<span class="c1"># Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
</span></code></pre></div></div>

<p><strong>Solution with DFS</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node. We need to modify tree node to help this solution work
</span><span class="k">class</span> <span class="nc">MyTreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span>

<span class="kn">import</span> <span class="n">math</span>

<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        </span><span class="sh">"""</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="sh">''</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">data</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
                <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode

        example: 
            input = [1,2,3,null,null,4,5] in level order format
            encoded = [1,2,N,N,3,4,N,N,5,N,N] in preorder format
        example 2: 
            input = [1,2,null,3,null,4,null,5] in level order format
            encoded = [1,2,3,4,5,N,N,N,N,N] in preorder format
        </span><span class="sh">"""</span>

        <span class="n">data_list</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data_list</span> <span class="o">==</span> <span class="p">[</span><span class="sh">''</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nc">MyTreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

            <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># to manage index of children in data_list
</span>
            <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">):</span>
                <span class="n">node_val</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">node_val</span> <span class="o">==</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="p">:</span>
                        <span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parent</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="nc">MyTreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">node_val</span><span class="p">))</span>
                    <span class="n">parent</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span><span class="p">:</span>
                        <span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parent</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">root</span>

<span class="c1"># Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
</span></code></pre></div></div>

<p><strong>Turn out that leetcode doesn’t allow me to implement MyTreeNode class, I don’t know why yet</strong>. So I gave up and found the superb solution from <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/solutions/396124/python-very-easy-to-understand-recursive-preorder-with-comments/" rel="external nofollow noopener" target="_blank">here</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="sh">'</span><span class="s">x</span><span class="sh">'</span>
        <span class="k">return</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="nf">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="nf">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="nf">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
		<span class="c1"># The reason I use self.data in the deserialize is, data stream will be consumed  as we build left side of Tree
</span>		<span class="c1"># by the time when the right side is building up, we need to hold what is left over.
</span>		<span class="c1"># Therefore, self.data is a global value, right side will use what is left over after tree is partially built
</span>        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[:</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">)])</span> 
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">deserialize</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">deserialize</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div>

<p><strong>Extension: How to serialize a binary tree to a string with minimal length?</strong></p>

<ul>
  <li>The first idea is to use level order traversal to serialize the tree. Whenever we encounter a sequence of <code class="language-plaintext highlighter-rouge">None</code> values, we replace it with 2 values <code class="language-plaintext highlighter-rouge">None</code> and <code class="language-plaintext highlighter-rouge">numbers_of_None</code> where <code class="language-plaintext highlighter-rouge">numbers_of_None</code> is the number of <code class="language-plaintext highlighter-rouge">None</code> values in the sequence. For example, the sequence <code class="language-plaintext highlighter-rouge">[1, 2, None, None, None, 3, 4, None, None, None, None]</code> will be serialized to <code class="language-plaintext highlighter-rouge">[1, 2, None, 3, 4, None, 4]</code>. This approach will be beneficial when the tree is sparse.</li>
  <li>The second idea is to pre-define a set of encode-decode rules that know in both sides. We then self-analyze the tree and encode it with optimal rules. The optimal rule also be sent to the other side to decode the tree. For example, the outer tree <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, None, None, 5]</code> can be encode as <code class="language-plaintext highlighter-rouge">out [1, 2, 3, 4, 5]</code>.</li>
</ul>

<h2 id="572-subtree-of-another-tree"><a href="https://leetcode.com/problems/subtree-of-another-tree/" rel="external nofollow noopener" target="_blank">572. Subtree of Another Tree</a></h2>

<font size="6"> Description </font>

<p>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</p>

<p>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.</p>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
</code></pre></div></div>

<p>Example 2:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in the root tree is in the range [1, 2000].</li>
  <li>The number of nodes in the subRoot tree is in the range [1, 1000].</li>
  <li>-10^4 &lt;= root.val &lt;= 10^4</li>
  <li>-10^4 &lt;= subRoot.val &lt;= 10^4</li>
</ul>

<font size="6"> Solution </font>

<p>The idea is to traverse the tree and convert to a list. If the list of the sub-tree is a sub-list of the list of the tree, then the sub-tree is a sub-tree of the tree. But we must use DFS instead of BFS because the order of the nodes in the list matters and DFS preserves the order of the nodes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">sub_tree</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">subRoot</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="n">tree</span>
</code></pre></div></div>

<p><strong>Turn out that the above approach just pass 181 over 182 test cases <img class="emoji" title=":joy:" alt=":joy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png" height="20" width="20">. The fail test case is actually very simple that I didn’t think of it. The test case is <code class="language-plaintext highlighter-rouge">root=[12]</code> and <code class="language-plaintext highlighter-rouge">subroot=[2]</code> so the function return <code class="language-plaintext highlighter-rouge">True</code> because the string <code class="language-plaintext highlighter-rouge">2</code> is in the string <code class="language-plaintext highlighter-rouge">12</code>. The solution is adding special symbols at the begin and end of each node value</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">'</span><span class="s">N</span><span class="sh">'</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span> <span class="o">+</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">sub_tree</span> <span class="o">=</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">subRoot</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="n">tree</span>
</code></pre></div></div>

<p><strong>My solution beats 98.03% of users with Python3 in term of Runtime <img class="emoji" title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20"> but just 18.95% in term of Memory</strong></p>

<h2 id="105-construct-binary-tree-from-preorder-and-inorder-traversal"><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" rel="external nofollow noopener" target="_blank">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h2>

<font size="6"> Description </font>

<p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2021/02/19/tree-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2021/02/19/tree-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2021/02/19/tree-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
</code></pre></div></div>

<p>Example 2:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: preorder = [-1], inorder = [-1]
Output: [-1]
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>1 &lt;= preorder.length &lt;= 3000</li>
  <li>inorder.length == preorder.length</li>
  <li>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</li>
  <li>preorder and inorder consist of unique values.</li>
  <li>Each value of inorder also appears in preorder.</li>
  <li>preorder is guaranteed to be the preorder traversal of the tree.</li>
  <li>inorder is guaranteed to be the inorder traversal of the tree.</li>
</ul>

<font size="6"> Solution </font>

<p>The problem is a bit ambiguous to me in the first place, because normally if we have either preorder or inorder traversal, we can construct the tree. But in this problem, we need both lists. And the reason is because we don’t have <code class="language-plaintext highlighter-rouge">None</code> or <code class="language-plaintext highlighter-rouge">null</code> values in the lists to indicate the end of the left or right sub-tree. Therefore, we need both lists and match the values in the lists to construct the tree.</p>

<p>Some important observations:</p>

<ul>
  <li>The first element in the preorder list is always the root of the tree.</li>
  <li>The root of the tree divides the inorder list into two parts: the left sub-tree and the right sub-tree.</li>
  <li>The root of the left sub-tree is the one in the preorder list that is right after the root of the tree.</li>
</ul>

<p>Based on the above observations, here is the solution</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">preorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">inorder</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">preorder</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">root_index</span> <span class="o">=</span> <span class="n">inorder</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">root_index</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">inorder</span><span class="p">[:</span><span class="n">root_index</span><span class="p">])</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">root_index</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">inorder</span><span class="p">[</span><span class="n">root_index</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div>

<h2 id="98-validate-binary-search-tree">98. <a href="https://leetcode.com/problems/validate-binary-search-tree/" rel="external nofollow noopener" target="_blank">Validate Binary Search Tree</a>
</h2>

<font size="6"> Description </font>

<p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p>

<p>A valid BST is defined as follows:</p>

<ul>
  <li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
  <li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
  <li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>Example 1:</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2020/12/01/tree1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2020/12/01/tree1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2020/12/01/tree1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [2,1,3]
Output: true
</code></pre></div></div>

<p>Example 2:</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2020/12/01/tree2-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2020/12/01/tree2-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2020/12/01/tree2-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in the tree is in the range [1, 10^4].</li>
  <li>-2^31 &lt;= Node.val &lt;= 2^31 - 1</li>
</ul>

<font size="6"> Solution </font>

<p>Clarification:</p>

<ul>
  <li>What if the tree like this <code class="language-plaintext highlighter-rouge">[5, 1, 6, null, null, 3, 7]</code>? It violates the BST property because the left child of 6 is 3 which is smaller than its grandparent 5. Therefore the expected output is <code class="language-plaintext highlighter-rouge">False</code>.</li>
</ul>

<p>So the solution is to use inorder traversal to traverse the tree and check if the values are in ascending order.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">output</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span> <span class="o">==</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="ow">and</span> <span class="nf">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="230-kth-smallest-element-in-a-bst"><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" rel="external nofollow noopener" target="_blank">230. Kth Smallest Element in a BST</a></h2>

<font size="6"> Description </font>

<p>Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.</p>

<p>Example 1:</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2021/01/28/kthtree1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2021/01/28/kthtree1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2021/01/28/kthtree1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [3,1,4,null,2], k = 1
Output: 1
</code></pre></div></div>

<p>Example 2:</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2021/01/28/kthtree2-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2021/01/28/kthtree2-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2021/01/28/kthtree2-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in the tree is n.</li>
  <li>1 &lt;= k &lt;= n &lt;= 10^4</li>
  <li>0 &lt;= Node.val &lt;= 10^4</li>
</ul>

<font size="6"> Solution </font>

<p>Similar to the above problem <a href="https://leetcode.com/problems/validate-binary-search-tree/" rel="external nofollow noopener" target="_blank">98. Validate Binary Search Tree</a>, we can use inorder traversal to traverse the tree and store the values in a list. Then we return the kth element in the list.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">output</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p><strong>My solution beats 90.98% of users with Python3 in term of Runtime and 95.87% in term of Memory</strong></p>

<h2 id="235-lowest-common-ancestor-of-a-binary-search-tree"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="external nofollow noopener" target="_blank">235. Lowest Common Ancestor of a Binary Search Tree</a></h2>

<font size="6"> Description </font>

<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>

<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor of two nodes p and q in a binary search tree (BST) is the lowest node in the tree that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>

<p>Example 1:</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
</code></pre></div></div>

<p>Example 2:</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</code></pre></div></div>

<p>Example 3:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: root = [2,1], p = 2, q = 1
Output: 2
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>The number of nodes in the tree is in the range [2, 10^5].</li>
  <li>-10^9 &lt;= Node.val &lt;= 10^9</li>
  <li>All Node.val are unique.</li>
  <li>p != q</li>
  <li>p and q will exist in the BST.</li>
</ul>

<font size="6"> Solution </font>

<!-- The idea is to apply inorder traverse and store the values in a list. Because all nodes' values are unique, we can find the index of the nodes in the list and return the root of the sub-tree formed from the sub-list.

We can also build a reverse tree where each node has its value and link to its parent. Then we can find the path from the two nodes to the root and find the first common node in the two paths. But how to find the starting node of a path? We can use a set to store the starting nodes (p, q nodes). -->

<p>Important observations:</p>

<ul>
  <li>The tree is BST, therefore, by definition, the left sub-tree of a node contains only nodes with keys less than the node’s key and the right sub-tree of a node contains only nodes with keys greater than the node’s key.</li>
  <li>we can check if the values of the root is between the values of the two nodes. If yes, then the root is the LCA. Otherwise, we can recursively check the left or right sub-tree of the root.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div>

<p>Another solution that might run faster and avoid recursion is to use a while loop which I found from <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solutions/64963/3-lines-with-o-1-space-1-liners-alternatives/" rel="external nofollow noopener" target="_blank">here</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">TreeNode</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
            <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div>

<h2 id="208-implement-trie-prefix-tree"><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" rel="external nofollow noopener" target="_blank">208. Implement Trie (Prefix Tree)</a></h2>

<font size="6"> Description </font>

<p>A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>

<p>Implement the Trie class:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Trie()</code> Initializes the trie object.</li>
  <li>
<code class="language-plaintext highlighter-rouge">void insert(String word)</code> Inserts the string word into the trie.</li>
  <li>
<code class="language-plaintext highlighter-rouge">boolean search(String word)</code> Returns <code class="language-plaintext highlighter-rouge">true</code> if the string <code class="language-plaintext highlighter-rouge">word</code> is in the trie (i.e., was inserted before), and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li>
  <li>
<code class="language-plaintext highlighter-rouge">boolean startsWith(String prefix)</code> Returns <code class="language-plaintext highlighter-rouge">true</code> if there is a previously inserted string <code class="language-plaintext highlighter-rouge">word</code> that has the prefix <code class="language-plaintext highlighter-rouge">prefix</code>, and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</li>
</ul>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
Output
[null, null, true, false, true, null, true]

Explanation
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>1 &lt;= word.length, prefix.length &lt;= 2000</li>
  <li>word and prefix consist only of lowercase English letters.</li>
  <li>At most 3 * 10^4 calls in total will be made to insert, search, and startsWith.</li>
</ul>

<font size="6"> Solution </font>

<p>We will use dictionary for this problem (I don’t understand why this question classified as a Tree problem). We can use one dictionary to store words and another dictionary to store all posible prefixes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">word_dict</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">prefix_dict</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">break_word</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">word</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">word_dict</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="nf">break_word</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">prefix_dict</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">word_dict</span>
        

    <span class="k">def</span> <span class="nf">startsWith</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">prefix_dict</span>


<span class="c1"># Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
</span></code></pre></div></div>

<p><strong>Surprisingly, my solution beats 94.76% of users with Python 3 in term of Memory even though I use two dictionaries.</strong></p>

<h2 id="211-design-add-and-search-words-data-structure"><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/" rel="external nofollow noopener" target="_blank">211. Design Add and Search Words Data Structure</a></h2>

<font size="6"> Description </font>

<p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>

<p>Implement the WordDictionary class:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">WordDictionary()</code> Initializes the object.</li>
  <li>
<code class="language-plaintext highlighter-rouge">void addWord(word)</code> Adds word to the data structure, it can be matched later.</li>
  <li>
<code class="language-plaintext highlighter-rouge">bool search(word)</code> Returns <code class="language-plaintext highlighter-rouge">true</code> if there is any string in the data structure that matches <code class="language-plaintext highlighter-rouge">word</code> or <code class="language-plaintext highlighter-rouge">false</code> otherwise. <code class="language-plaintext highlighter-rouge">word</code> may contain dots ‘.’ where dots can be matched with any letter.</li>
</ul>

<p>Example 1:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output
[null,null,null,null,false,true,true,true]

Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li>1 &lt;= word.length &lt;= 500</li>
  <li>word in addWord consists lower-case English letters.</li>
  <li>word in search consist of  ‘.’ or lower-case English letters.</li>
  <li>There will be at most 2 dots in word for search queries.</li>
  <li>At most 10000 calls will be made to addWord and search.</li>
</ul>

<font size="6"> Solution </font>

<p>We can still use dictionary as in the previous problem, but with a bit modification. We need a specific function to replace at most two characters in each word by <code class="language-plaintext highlighter-rouge">dot</code> and store the new words in the dictionary.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">WordDictionary</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">word_dict</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">replace_char</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># replace one character
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="n">output</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s">.</span><span class="sh">'</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1"># replace two characters
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
                <span class="n">output</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s">.</span><span class="sh">'</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s">.</span><span class="sh">'</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">output</span>
    

    <span class="k">def</span> <span class="nf">addWord</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">word_dict</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">new_word</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="nf">replace_char</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">word_dict</span><span class="p">[</span><span class="n">new_word</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">word_dict</span>


<span class="c1"># Your WordDictionary object will be instantiated and called as such:
# obj = WordDictionary()
# obj.addWord(word)
# param_2 = obj.search(word)
</span></code></pre></div></div>

<p><strong>Turn out that my solution is bad <img class="emoji" title=":joy:" alt=":joy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png" height="20" width="20"> because it beats only 5% of users with Python 3 in term of Runtime and Memory. Maybe we need a Tree approach. I think my solution might be good in the scenario when we need search more than addWord operations. Because the heaviest task is to break the word into new words and store them in the dictionary.</strong></p>

<!-- In the following solution, I will split tasks into two functions. The `break_word` function will split a word into two parts: prefix and suffix. The `addWord` will store word, its prefix and suffix in two dictionaries. The main difference is in the `search` function where we need to consider three scenarios:

- If there is no dot in the word, we just need to check if the word is in the dictionary.
- If there is only one dot, we need to check if the prefix is in the prefix dictionary and the suffix is matched with the associated value in the prefix dictionary.
- If there is two dots, we need to check if the prefix is in the prefix dictionary. If yes, we need to replace the dot in the suffix and check if it is matched with the query word.

```python
class WordDictionary:

    def __init__(self):
        self.word_dict = dict()
        self.prefix_dict = dict()

    def break_word(self, word):
        output = []
        for i in range(len(word)):
            output.append((word[:i], word[i:]))
        return output

    def addWord(self, word: str) -> None:
        self.word_dict[word] = True 
        for prefix, suffix in self.break_word(word):
            if prefix not in self.prefix_dict:
                self.prefix_dict[prefix] = []
            self.prefix_dict[prefix].append(suffix)

    def search(self, word: str) -> bool:
        if '.' not in word:
            return word in self.word_dict
        elif word.count('.') == 1:
            prefix, suffix = word.split('.')
            if prefix in self.prefix_dict:
                return suffix in self.prefix_dict[prefix]
            else:
                return False
        else:
            prefix, suffix = word.split('.')
            if prefix in self.prefix_dict:
                for s in self.prefix_dict[prefix]:
                    if s == suffix:
                        return True
                    elif s.count('.') == 1:
                        s_prefix, s_suffix = s.split('.')
                        if s_prefix == suffix:
                            return True
            return False
``` -->

<h2 id="212-word-search-ii"><a href="https://leetcode.com/problems/word-search-ii/" rel="external nofollow noopener" target="_blank">212. Word Search II</a></h2>

<font size="6"> Description </font>

<p>Given an <code class="language-plaintext highlighter-rouge">m x n</code> board of characters and a list of strings words, return all words on the board.</p>

<p>Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>

<p>Example 1:</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2020/11/07/search1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2020/11/07/search1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2020/11/07/search1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
</code></pre></div></div>

<p>Example 2:</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://assets.leetcode.com/uploads/2020/11/07/search2-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://assets.leetcode.com/uploads/2020/11/07/search2-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://assets.leetcode.com/uploads/2020/11/07/search2-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: board = [["a","b"],["c","d"]], words = ["abcb"]
Output: []
</code></pre></div></div>

<p>Constraints:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">m == board.length</code></li>
  <li><code class="language-plaintext highlighter-rouge">n == board[i].length</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= m, n &lt;= 12</code></li>
  <li>
<code class="language-plaintext highlighter-rouge">board[i][j]</code> is a lowercase English letter.</li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= words.length &lt;= 3 * 104</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= words[i].length &lt;= 10</code></li>
  <li>
<code class="language-plaintext highlighter-rouge">words[i]</code> consists of lowercase English letters.</li>
  <li>All the strings of words are unique.</li>
</ul>

<font size="6"> Solution </font>

<p>I have to refer to some solutions (<a href="https://leetcode.com/problems/word-search-ii/solutions/3224569/212-beats-94-solution-with-step-by-step-explanation/" rel="external nofollow noopener" target="_blank">here</a> and <a href="https://leetcode.com/problems/word-search-ii/solutions/3224569/212-beats-94-solution-with-step-by-step-explanation/" rel="external nofollow noopener" target="_blank">here</a>) to find out how to solve this problem. The idea is to use <a href="#trie">Trie</a> to store the words and use DFS to traverse the board to find all possible words.</p>

<p>Clarification: Because the same letter cell may not be used more than once in a word, we need to keep track of the visited cells in the board. We can use a set to store the visited cells or we can modify the board by replacing the visited cells with a special character (e.g. <code class="language-plaintext highlighter-rouge">#</code>), but it will cost more memory because we need to carry out the modified board recursively.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">isEndOfWord</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
        <span class="n">node</span><span class="p">.</span><span class="n">isEndOfWord</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">isEndOfWord</span> <span class="ow">or</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">add_boundary</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    a helper function to add boundary to the board
    board with size m x n --&gt; board with size (m+2) x (n+2)
    </span><span class="sh">"""</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">new_board</span> <span class="o">=</span> <span class="p">[[</span><span class="sh">'</span><span class="s">#</span><span class="sh">'</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">new_board</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="sh">'</span><span class="s">#</span><span class="sh">'</span><span class="p">]</span> <span class="o">+</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="sh">'</span><span class="s">#</span><span class="sh">'</span><span class="p">])</span>
    <span class="n">new_board</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="sh">'</span><span class="s">#</span><span class="sh">'</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_board</span>
    

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findWords</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">def</span> <span class="nf">build_trie</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">board</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">trie</span> <span class="o">=</span> <span class="nc">Trie</span><span class="p">()</span>

        
        <span class="n">self</span><span class="p">.</span><span class="nf">build_trie</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">trie</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
                <span class="n">output</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

</code></pre></div></div>

<h2 id="reflection-binary-tree-problems">Reflection: Binary Tree Problems?</h2>

<p>This is a placeholder for me to reflect what I have learned to solve the binary tree problems. So far</p>

<ul>
  <li>Tree traversal algorithms are the foundation of solving binary tree problems.</li>
  <li>Recursion and Recursive thinking</li>
  <li>The base case of the recursion is very important. It is the condition that stops the recursion.</li>
  <li>Trie is a tree data structure that is used to store strings. It is very useful in solving string problems.</li>
</ul>

<p>I also found that the following resources are very useful:</p>

<ul>
  <li>
<a href="https://youtu.be/s2Yyk3qdy3o?si=D-bOndNHktjDEC3j" rel="external nofollow noopener" target="_blank">How to solve (almost) any binary tree coding problem</a> by Inside code.
    <ul>
      <li>Finding one or more base cases</li>
      <li>Calling the same function on the left subtree</li>
      <li>Calling the same function on the right subtree</li>
      <li>Joining the results</li>
    </ul>
  </li>
</ul>

<h3 id="revisit-tree-traversal-techniques"><a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/" rel="external nofollow noopener" target="_blank">Revisit: Tree Traversal Techniques</a></h3>

<p>Source: <a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/" rel="external nofollow noopener" target="_blank">https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/</a></p>

<font size="6"> What is tree traversal? </font>

<p>Tree traversal is the process of visiting (checking and/or updating) each node in a tree data structure, exactly once. Such traversals are classified by the order in which the nodes are visited. Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways. Two most important ways are traversal by level (BFS) and traversal by depth (DFS).</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20230623123129/traversal-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20230623123129/traversal-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20230623123129/traversal-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230623123129/traversal.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<div class="caption">
    Tree Traversal Example
</div>

<font size="6"> Inorder Traversal </font>

<blockquote class="block-warning">
  <p><strong>Inorder Traversal Algorithm</strong></p>

  <ol>
    <li>Traverse the left subtree, i.e., call Inorder(left-subtree)</li>
    <li>Visit the root.</li>
    <li>Traverse the right subtree, i.e., call Inorder(right-subtree)</li>
  </ol>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
</span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<font size="6"> Preorder Traversal </font>

<blockquote class="block-warning">
  <p><strong>Preorder Traversal Algorithm</strong></p>

  <ol>
    <li>Visit the root.</li>
    <li>Traverse the left subtree, i.e., call Preorder(left-subtree)</li>
    <li>Traverse the right subtree, i.e., call Preorder(right-subtree)</li>
  </ol>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
</span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">preorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="nf">preorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="nf">preorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<p>Problems:</p>

<ul>
  <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" rel="external nofollow noopener" target="_blank">104. Maximum Depth of Binary Tree</a></li>
</ul>

<font size="6"> Postorder Traversal </font>

<blockquote class="block-warning">
  <p><strong>Postorder Traversal Algorithm</strong></p>

  <ol>
    <li>Traverse the left subtree, i.e., call Postorder(left-subtree)</li>
    <li>Traverse the right subtree, i.e., call Postorder(right-subtree)</li>
    <li>Visit the root.</li>
  </ol>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
</span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">postorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">postorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="nf">postorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
</code></pre></div></div>

<font size="6"> Level Order Traversal </font>

<blockquote class="block-warning">
  <p><strong>Level Order Traversal Algorithm</strong></p>

  <ol>
    <li>Create an empty queue q</li>
    <li>Enqueue root to q</li>
    <li>Loop while q is not empty <br>
a. Dequeue a node from q and print its value <br>
b. Enqueue node’s children (first left then right children) to q if they are not null</li>
  </ol>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simple implementation of a queue using a list
</span><span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<p>The following code snippet shows how to implement the BFS algorithm to traverse the tree.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simple BFS implementation
</span><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
    <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">queue</span><span class="p">.</span><span class="nf">is_empty</span><span class="p">():</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="-revisit-trie-data-structure">
<a name="trie"></a> Revisit Trie Data Structure</h3>

<p>Source: <a href="https://www.geeksforgeeks.org/trie-insert-and-search/" rel="external nofollow noopener" target="_blank">https://www.geeksforgeeks.org/trie-insert-and-search/</a></p>

<font size="6"> What is Trie? </font>

<p>In short, Trie is a k-ary tree where k is the largest number of children of a node.</p>

<p>Because of its structure, Trie is an efficient information retrieval data structure. Using Trie, search complexities can be brought to optimal limit (key length). If we store keys in binary search tree, a well balanced BST will need time proportional to <code class="language-plaintext highlighter-rouge">M * log N</code>, where M is maximum string length and N is number of keys in tree. Using Trie, we can search the key in <code class="language-plaintext highlighter-rouge">O(M)</code> time. However the penalty is on Trie storage requirements.</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220828232752/Triedatastructure1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220828232752/Triedatastructure1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220828232752/Triedatastructure1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220828232752/Triedatastructure1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<div class="caption">
    Trie Example. In this example, it is assumed that only English alphabets are used. Therefore, each node can have at most 26 children, even it looks like a binary tree.
</div>

<p>The following code is a simple Trie for English alphabet.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
     
    <span class="c1"># Trie node class
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="mi">26</span>
 
        <span class="c1"># isEndOfWord is True if node represent the end of the word
</span>        <span class="n">self</span><span class="p">.</span><span class="n">isEndOfWord</span> <span class="o">=</span> <span class="bp">False</span>
</code></pre></div></div>

<font size="6"> Insert and Search Opeartions </font>

<p>To insert a key to Trie, we need to do the following steps:</p>

<ul>
  <li>Starting from the root, we check if the current node has a child corresponding to the first character of the key. If yes, we move to that child and continue to check the next character.</li>
  <li>If no, we create a new node and link it to the current node.</li>
  <li>We repeat the above steps until we reach the last character of the key. Then we mark the last node as the end of the key.</li>
</ul>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220902035030/ex1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220902035030/ex1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220902035030/ex1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220902035030/ex1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<div class="caption">
    Insertion example
</div>

<p>To search a key in Trie, we need to do the following steps:</p>

<ul>
  <li>Starting from the root, we check if the current node has a child corresponding to the first character of the key. If yes, we move to that child and continue to check the next character.</li>
  <li>If no, we return <code class="language-plaintext highlighter-rouge">False</code>.</li>
  <li>We repeat the above steps until we reach the last character of the key. Then we return <code class="language-plaintext highlighter-rouge">True</code> if the last node is marked as the end of the key.</li>
</ul>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220831073313/search1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220831073313/search1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220831073313/search1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220831073313/search1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<div class="caption">
    Search example
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">chartoIndex</span><span class="p">(</span><span class="n">ch</span><span class="p">):</span>
    <span class="c1"># private helper function
</span>    <span class="c1"># Converts key current character into index
</span>    <span class="c1"># use only 'a' through 'z' and lower case
</span>    <span class="k">return</span> <span class="nf">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span><span class="o">-</span><span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span> 
        <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nf">chartoIndex</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">cur</span><span class="p">.</span><span class="n">isEndOfWord</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nf">chartoIndex</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cur</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">.</span><span class="n">isEndOfWord</span>
</code></pre></div></div>

<p>Another implementation of Trie is to use dictionary which is preferred in Leetcode.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">isEndOfWord</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
        <span class="n">cur</span><span class="p">.</span><span class="n">isEndOfWord</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cur</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">cur</span><span class="p">.</span><span class="n">isEndOfWord</span>
</code></pre></div></div>

    </div>
  </article>


  
    
    <br>
    <hr>
    <br>
    <ul class="list-disc pl-8"></ul>

    <!-- Adds related posts to the end of an article -->
    <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2>
    <p class="mb-2">Here are some more articles you might like to read next:</p>
  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/watermark-diffusion/">Tree-Ring Watermarks - Fingerprints for Diffusion Images that are Invisible and Robust</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/fairness-irt/">Comprehensive Algorithm Portfolio Evaluation using Item Response Theory</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/aml-intro/">Tutorial on Adversarial Machine Learning - Part 1</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/aml-overview/">Tutorial on Adversarial Machine Learning - Part 2</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/conditional-diffusion/">Diffusion Models Beat GANs on Image Synthesis</a>
  </li>

</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2023 Tuan-Anh  Bui. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script>
  <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script>
  <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7KGSMMS9MS"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-7KGSMMS9MS');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

    
  </body>
</html>
