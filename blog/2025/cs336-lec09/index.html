<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>CS336 Lecture 9 - Scaling laws | Tuan-Anh  Bui</title>
    <meta name="author" content="Tuan-Anh  Bui">
    <meta name="description" content="AI Summary of CS336 Lecture">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e">
    <link rel="canonical" href="https://tuananhbui89.github.io/blog/2025/cs336-lec09/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">
    <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script>
    <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Tuan-Anh </span>Bui</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">projects</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/repositories/">repositories</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/teaching/"></a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->
<!-- Page/Post style -->
<style type="text/css">
  
</style>


<div class="post">

  <header class="post-header">
    <h1 class="post-title">CS336 Lecture 9 - Scaling laws</h1>
    <p class="post-meta">December 8, 2025</p>
    <p class="post-tags">
      <a href="/blog/2025"> <i class="fas fa-calendar fa-sm"></i> 2025 </a>
        ·  
        <a href="/blog/tag/genai">
          <i class="fas fa-hashtag fa-sm"></i> genai</a>  
          <a href="/blog/tag/llm">
          <i class="fas fa-hashtag fa-sm"></i> llm</a>  
          <a href="/blog/tag/tutorial">
          <i class="fas fa-hashtag fa-sm"></i> tutorial</a>  
          <a href="/blog/tag/reading">
          <i class="fas fa-hashtag fa-sm"></i> reading</a>  
          

    </p>
  </header>

  <article class="post-content">
    
    <div id="table-of-contents">
      <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#scaling-laws-provide-a-predictive-framework-for-extrapolating-small-model-experiments-to-guide-large-model-design">Scaling laws provide a predictive framework for extrapolating small-model experiments to guide large-model design</a></li>
<li class="toc-entry toc-h1"><a href="#scaling-laws-aim-to-produce-simple-predictive-relationships-between-model-resources-data-parameters-compute-and-model-performance">Scaling laws aim to produce simple, predictive relationships between model resources (data, parameters, compute) and model performance</a></li>
<li class="toc-entry toc-h1"><a href="#scaling-laws-connect-to-classical-statistical-learning-theory-but-operate-on-empirical-realized-losses-rather-than-worst-case-upper-bounds">Scaling laws connect to classical statistical learning theory but operate on empirical realized losses rather than worst-case upper bounds</a></li>
<li class="toc-entry toc-h1"><a href="#early-empirical-scaling-law-thinking-predates-modern-deep-learning-and-proposed-fitting-predictive-performance-curves-to-avoid-full-scale-training">Early empirical scaling-law thinking predates modern deep learning and proposed fitting predictive performance curves to avoid full-scale training</a></li>
<li class="toc-entry toc-h1"><a href="#empirical-neural-scaling-laws-exhibit-three-phasesrandominitial-power-law-scaling-and-asymptotic-irreducible-errorand-are-surprisingly-predictive-across-domains">Empirical neural scaling laws exhibit three phases—random/initial, power-law scaling, and asymptotic irreducible error—and are surprisingly predictive across domains</a></li>
<li class="toc-entry toc-h1"><a href="#scaling-behavior-can-break-down-for-out-of-distribution-or-narrowly-defined-failure-modes-producing-non-scaling-or-inverse-scaling-phenomena">Scaling behavior can break down for out-of-distribution or narrowly defined failure modes, producing non-scaling or inverse-scaling phenomena</a></li>
<li class="toc-entry toc-h1"><a href="#large-language-model-scaling-exhibits-consistent-log-log-linear-relationships-across-compute-data-and-parameters-when-measured-in-appropriate-regimes">Large language model scaling exhibits consistent log-log linear relationships across compute, data, and parameters when measured in appropriate regimes</a></li>
<li class="toc-entry toc-h1"><a href="#data-scaling-laws-map-dataset-size-n-to-excess-error-and-typically-show-log-log-linear-power-law-decay-in-the-productive-regime">Data-scaling laws map dataset size n to excess error and typically show log-log linear (power-law) decay in the productive regime</a></li>
<li class="toc-entry toc-h1"><a href="#simple-parametric-estimation-tasks-yield-power-law-rates-eg-mean-estimation-scales-as-1n-while-nonparametric-function-estimation-introduces-intrinsic-dimension-dependent-slower-rates">Simple parametric estimation tasks yield power-law rates (e.g., mean estimation scales as 1/n) while nonparametric function estimation introduces intrinsic-dimension-dependent slower rates</a></li>
<li class="toc-entry toc-h1"><a href="#observed-empirical-exponents-for-language-related-tasks-are-often-much-smaller-than-simple-parametric-rates-reflecting-high-intrinsic-complexity">Observed empirical exponents for language-related tasks are often much smaller than simple parametric rates, reflecting high intrinsic complexity</a></li>
<li class="toc-entry toc-h1"><a href="#generating-synthetic-data-with-controlled-intrinsic-dimensionality-is-straightforward-but-estimating-real-data-intrinsic-dimension-is-challenging">Generating synthetic data with controlled intrinsic dimensionality is straightforward, but estimating real data intrinsic dimension is challenging</a></li>
<li class="toc-entry toc-h1"><a href="#data-scaling-laws-enable-practical-engineering-decisions-such-as-dataset-composition-optimal-mixing-and-assessing-diminishing-returns-from-repetitions">Data-scaling laws enable practical engineering decisions such as dataset composition, optimal mixing, and assessing diminishing returns from repetitions</a></li>
<li class="toc-entry toc-h1"><a href="#when-analyzing-data-scaling-behavior-the-model-size-used-for-evaluation-must-be-large-enough-to-avoid-parameter-limited-saturation">When analyzing data-scaling behavior, the model size used for evaluation must be large enough to avoid parameter-limited saturation</a></li>
<li class="toc-entry toc-h1"><a href="#model-scaling-analysis-addresses-trade-offs-among-architectures-optimizers-hyperparameters-and-resource-allocation-for-deployment">Model-scaling analysis addresses trade-offs among architectures, optimizers, hyperparameters, and resource allocation for deployment</a></li>
<li class="toc-entry toc-h1"><a href="#optimizer-choice-and-depthwidthaspect-ratio-choices-can-be-evaluated-via-scaling-curves-to-find-scale-robust-hyperparameter-regimes">Optimizer choice and depth/width/aspect-ratio choices can be evaluated via scaling curves to find scale-robust hyperparameter regimes</a></li>
<li class="toc-entry toc-h1"><a href="#not-all-parameters-are-equivalent-embedding-and-sparsely-activated-parameters-change-scaling-law-behavior-and-require-normalization">Not all parameters are equivalent; embedding and sparsely activated parameters change scaling-law behavior and require normalization</a></li>
<li class="toc-entry toc-h1"><a href="#batch-size-exhibits-a-critical-threshold-beyond-which-returns-diminish-and-the-critical-batch-size-itself-scales-with-target-loss">Batch size exhibits a critical threshold beyond which returns diminish, and the critical batch size itself scales with target loss</a></li>
<li class="toc-entry toc-h1"><a href="#learning-rate-optima-vary-with-model-width-under-standard-parameterizations-but-scale-stable-reparameterizations-eg-%CE%BCpnew-p-can-make-the-optimal-learning-rate-transfer-across-widths">Learning-rate optima vary with model width under standard parameterizations, but scale-stable reparameterizations (e.g., μP/new-p) can make the optimal learning rate transfer across widths</a></li>
<li class="toc-entry toc-h1"><a href="#batch-size-and-learning-rate-interact-via-gradient-noise-considerations-and-their-optimal-pairing-can-change-with-loss-targets-and-modality">Batch size and learning rate interact via gradient-noise considerations, and their optimal pairing can change with loss targets and modality</a></li>
<li class="toc-entry toc-h1"><a href="#log-loss-next-token-prediction-scaling-is-robust-and-predictable-but-downstream-task-scaling-and-capability-emergence-can-be-far-less-predictable">Log-loss (next-token prediction) scaling is robust and predictable, but downstream task scaling and capability emergence can be far less predictable</a></li>
<li class="toc-entry toc-h1"><a href="#scaling-law-based-design-prescribes-training-small-models-across-orders-of-magnitude-fitting-scaling-relationships-and-extrapolating-optimal-hyperparameters-and-architectures-to-full-scale">Scaling-law-based design prescribes training small models across orders of magnitude, fitting scaling relationships, and extrapolating optimal hyperparameters and architectures to full scale</a></li>
<li class="toc-entry toc-h1"><a href="#joint-datamodel-scaling-laws-iso-flop-trade-offs-describe-how-loss-decomposes-into-data-dependent-and-model-dependent-components-and-enable-optimal-compute-allocation">Joint data–model scaling laws (iso-flop trade-offs) describe how loss decomposes into data-dependent and model-dependent components and enable optimal compute allocation</a></li>
<li class="toc-entry toc-h1"><a href="#the-chinchilla-analysis-operationalized-iso-flop-optimization-and-indicated-an-approximately-20-tokens-per-parameter-budget-under-its-assumptions">The Chinchilla analysis operationalized iso-flop optimization and indicated an approximately 20 tokens-per-parameter budget under its assumptions</a></li>
<li class="toc-entry toc-h1"><a href="#method-1-minimum-envelope-finds-the-optimal-model-size-and-data-allocation-by-taking-the-lower-envelope-across-many-training-curves">Method 1 (minimum-envelope) finds the optimal model-size and data allocation by taking the lower envelope across many training curves</a></li>
<li class="toc-entry toc-h1"><a href="#method-2-isoflop-analysis-finds-the-optimal-parameterdata-trade-off-by-minimizing-loss-along-fixed-flop-slices-and-reading-out-the-minima">Method 2 (isoflop analysis) finds the optimal parameter/data trade-off by minimizing loss along fixed-flop slices and reading out the minima</a></li>
<li class="toc-entry toc-h1"><a href="#method-3-direct-joint-functional-fitting-fits-a-parametric-two-variable-surface-to-observed-runs-but-requires-careful-regression-to-avoid-biased-coefficients">Method 3 (direct joint functional fitting) fits a parametric two-variable surface to observed runs but requires careful regression to avoid biased coefficients</a></li>
<li class="toc-entry toc-h1"><a href="#inference-cost-and-deployment-considerations-have-shifted-preferred-training-regimes-toward-much-higher-tokens-per-parameter-ratios">Inference cost and deployment considerations have shifted preferred training regimes toward much higher tokens-per-parameter ratios</a></li>
<li class="toc-entry toc-h1"><a href="#scaling-law-methodologies-generalize-to-different-generative-architectures-eg-diffusion-text-models-and-often-reproduce-similar-iso-flop-minima-separated-by-constant-offsets">Scaling-law methodologies generalize to different generative architectures (e.g., diffusion text models) and often reproduce similar iso-flop minima separated by constant offsets</a></li>
<li class="toc-entry toc-h1"><a href="#log-linear-scaling-across-data-parameters-and-compute-provides-a-unifying-empirical-foundation-for-many-practical-model-design-and-resource-allocation-decisions">Log-linear scaling across data, parameters, and compute provides a unifying empirical foundation for many practical model-design and resource-allocation decisions</a></li>
</ul>
    </div>
    <hr>
    
    <div id="markdown-content">
      <div style="display: flex; justify-content: center;">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/6Q-ESEmDf4Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
    </iframe>
</div>

<h1 id="scaling-laws-provide-a-predictive-framework-for-extrapolating-small-model-experiments-to-guide-large-model-design">Scaling laws provide a predictive framework for extrapolating small-model experiments to guide large-model design</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-00-52-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-00-52-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-00-52-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-00-52.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Scaling laws formalize using systematic <strong>small-scale experiments</strong> to predict the behavior of much larger models, reducing the compute and human cost of hyperparameter and architecture search.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> train many small models across a range of sizes or compute budgets, fit simple functional forms to observed <strong>loss</strong> or <strong>metric trajectories</strong>, and extrapolate those fits to select configurations for a single large-scale run.<br>
</li>
  <li>
<strong>Rationale:</strong> avoid prohibitively expensive brute‑force tuning at full scale by relying on empirically validated extrapolations.<br>
</li>
  <li>
<strong>Implementation notes:</strong> ensure small-scale experiments cover the relevant regime (e.g., the <strong>power-law region</strong>) and use robust distributed training, data pipelines, and infra so extrapolation isn’t dominated by engineering artifacts.<br>
</li>
</ul>

<p>This approach is especially useful in frontier labs where a single successful large-scale training run is the objective.<br></p>

<hr>

<h1 id="scaling-laws-aim-to-produce-simple-predictive-relationships-between-model-resources-data-parameters-compute-and-model-performance">Scaling laws aim to produce simple, predictive relationships between model resources (data, parameters, compute) and model performance</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-02-30-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-02-30-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-02-30-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-02-30.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p><strong>Scaling laws</strong> seek simple mathematical relationships that predict how performance metrics change when resources (dataset size, model parameters, compute) increase.<br></p>

<ul>
  <li>
<strong>Central idea:</strong> fit compact empirical functions on small-scale runs and use them to make engineering decisions for larger runs.<br>
</li>
  <li>
<strong>Empirical regime:</strong> rely on monotonic, often approximately <strong>power-law</strong> dependencies where the model is not yet saturated by <strong>irreducible error</strong>.<br>
</li>
  <li>
<strong>Guidance produced:</strong> choices such as optimal parameter counts, data budgets, and compute allocations.<br>
</li>
  <li>
<strong>Practical requirement:</strong> choose resource ranges that avoid pathological regimes (random guessing or asymptotic irreducible error) so fitted forms are valid for extrapolation.<br>
</li>
  <li>
<strong>Program design:</strong> couple careful experimental design with regression or surface‑fitting techniques to quantify uncertainty in extrapolations.<br>
</li>
</ul>

<hr>

<h1 id="scaling-laws-connect-to-classical-statistical-learning-theory-but-operate-on-empirical-realized-losses-rather-than-worst-case-upper-bounds">Scaling laws connect to classical statistical learning theory but operate on empirical realized losses rather than worst-case upper bounds</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-04-21-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-04-21-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-04-21-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-04-21.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p><strong>Classical theory</strong> (VC dimension, Rademacher complexity, nonparametric rates) gives asymptotic/worst-case bounds (e.g., O(1/√n) or n^{-β/(2β+1})) but these are upper bounds rather than observed loss trajectories.<br></p>

<ul>
  <li>
<strong>Role of scaling laws:</strong> empirically fit functional relationships between dataset size, model capacity, and realized test loss to provide operational predictions for modern high-capacity models that violate simple theoretical assumptions.<br>
</li>
  <li>
<strong>Mechanism:</strong> treat empirical loss as the observable and use parametric or semi‑parametric curve fitting (e.g., <strong>power laws</strong>) across many runs to estimate exponents and offsets.<br>
</li>
  <li>
<strong>Rationale:</strong> empirical fits often deliver much tighter, actionable guidance than generic theory, especially for highly overparameterized neural networks.<br>
</li>
  <li>
<strong>Implementation considerations:</strong> carefully average over random seeds and use consistent evaluation metrics so fitted curves reflect true model behavior rather than noise.<br>
</li>
</ul>

<hr>

<h1 id="early-empirical-scaling-law-thinking-predates-modern-deep-learning-and-proposed-fitting-predictive-performance-curves-to-avoid-full-scale-training">Early empirical scaling-law thinking predates modern deep learning and proposed fitting predictive performance curves to avoid full-scale training</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-06-33-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-06-33-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-06-33-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-06-33.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Work since the early 1990s proposed predicting classifier performance from partial or small-scale runs to select promising configurations without training full models.<br></p>

<ul>
  <li>
<strong>Historical mechanism:</strong> decompose test error into <strong>irreducible error</strong> plus polynomially decaying terms, train many small models, fit decay curves (polynomial/power-law), and extrapolate to larger regimes — directly analogous to modern scaling-law practice.<br>
</li>
  <li>
<strong>Practical context:</strong> these historical results validate that systematic small-scale experiments can guide large-scale decisions and that power-law‑like fits often capture dominant behavior in the productive regime.<br>
</li>
  <li>
<strong>Implementation note:</strong> validate fitted functional forms against held-out experiments to avoid overconfident or biased extrapolation.<br>
</li>
</ul>

<hr>

<h1 id="empirical-neural-scaling-laws-exhibit-three-phasesrandominitial-power-law-scaling-and-asymptotic-irreducible-errorand-are-surprisingly-predictive-across-domains">Empirical neural scaling laws exhibit three phases—random/initial, power-law scaling, and asymptotic irreducible error—and are surprisingly predictive across domains</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-09-03-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-09-03-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-09-03-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-09-03.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Empirical studies across translation, speech, and vision identify a characteristic three‑phase curve shape for loss versus resources:<br></p>

<ol>
  <li>
<strong>Initial region near random performance</strong> — difficult to extrapolate.<br>
</li>
  <li>
<strong>Middle regime</strong> where loss decreases approximately as a <strong>power law</strong> with resources — the predictive domain for scaling laws.<br>
</li>
  <li>
<strong>Asymptotic region</strong> approaching <strong>irreducible error</strong> where gains taper off and extrapolation is unreliable.<br>
</li>
</ol>

<ul>
  <li>
<strong>Mechanistic insight:</strong> scaling-law procedures restrict fits to the intermediate regime where predictions are most reliable.<br>
</li>
  <li>
<strong>Practical implication:</strong> design experiments to avoid model saturation so the middle regime is well sampled.<br>
</li>
  <li>
<strong>Robustness:</strong> this three‑phase behavior appears across architectures and tasks and underpins confidence that small-scale experiments can inform large-scale outcomes when the right regime is targeted.<br>
</li>
</ul>

<hr>

<h1 id="scaling-behavior-can-break-down-for-out-of-distribution-or-narrowly-defined-failure-modes-producing-non-scaling-or-inverse-scaling-phenomena">Scaling behavior can break down for out-of-distribution or narrowly defined failure modes, producing non-scaling or inverse-scaling phenomena</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-11-11-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-11-11-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-11-11-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-11-11.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Scaling is natural for metrics like <strong>held-out training loss</strong> because improvement is typically monotonic with more data or capacity, but some capabilities or pathological behaviors can degrade with scale.<br></p>

<ul>
  <li>
<strong>Examples:</strong> tasks from inverse-scaling studies where certain capabilities become worse as models grow, or where extreme out‑of‑distribution (OOD) performance does not improve monotonically.<br>
</li>
  <li>
<strong>Mechanism for non-scaling:</strong> occurs when the evaluation domain drifts far from the training distribution or when tasks depend on brittle heuristics that do not benefit from capacity in conventional ways.<br>
</li>
  <li>
<strong>Practical implication:</strong> extrapolation must be <strong>task-aware</strong> — don’t assume universal log‑log linearity for all downstream behaviors; directly measure the phenomenon of interest across scale to verify the assumed scaling.<br>
</li>
</ul>

<hr>

<h1 id="large-language-model-scaling-exhibits-consistent-log-log-linear-relationships-across-compute-data-and-parameters-when-measured-in-appropriate-regimes">Large language model scaling exhibits consistent log-log linear relationships across compute, data, and parameters when measured in appropriate regimes</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-12-49-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-12-49-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-12-49-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-12-49.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>When evaluated on <strong>next-token prediction</strong> or other log‑loss metrics in the middle power‑law regime, models show approximately linear trends on log‑log plots between resource axes (compute, data, parameters) and test loss.<br></p>

<ul>
  <li>
<strong>Empirical mechanism:</strong> hold one resource large enough to avoid saturation and vary the other to reveal the power‑law region (e.g., keep model size large while varying data to study data scaling).<br>
</li>
  <li>
<strong>Rationale:</strong> log‑log linearity (power laws) is a compact functional form that fits many empirical curves, enabling interpolation and extrapolation across orders of magnitude.<br>
</li>
  <li>
<strong>Implementation caveat:</strong> ensure the held‑constant resource is actually large enough and that evaluation is done in a regime where the power‑law model is valid before extrapolating.<br>
</li>
</ul>

<hr>

<h1 id="data-scaling-laws-map-dataset-size-n-to-excess-error-and-typically-show-log-log-linear-power-law-decay-in-the-productive-regime">Data-scaling laws map dataset size n to excess error and typically show log-log linear (power-law) decay in the productive regime</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-14-06-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-14-06-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-14-06-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-14-06.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p><strong>Data‑scaling analysis</strong> focuses on the <strong>excess error</strong> (error above irreducible noise) as a function of the number of unique training tokens n and often finds error ∝ n^{-α} in the power‑law regime.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> train models with fixed high capacity while varying dataset sizes, plot test loss versus n on log‑log axes, and fit a straight line to estimate the exponent α.<br>
</li>
  <li>
<strong>Rationale:</strong> identifying α and the offset enables predictions about how much additional data is needed to achieve a target reduction in loss and supports tradeoffs like data collection vs. compute allocation.<br>
</li>
  <li>
<strong>Implementation notes:</strong> focus on <strong>unique‑token counts</strong> (account for repeated‑epoch effects separately) and validate that the fitted exponent is stable across model sizes within the power‑law region.<br>
</li>
</ul>

<hr>

<h1 id="simple-parametric-estimation-tasks-yield-power-law-rates-eg-mean-estimation-scales-as-1n-while-nonparametric-function-estimation-introduces-intrinsic-dimension-dependent-slower-rates">Simple parametric estimation tasks yield power-law rates (e.g., mean estimation scales as 1/n) while nonparametric function estimation introduces intrinsic-dimension-dependent slower rates</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-15-47-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-15-47-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-15-47-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-15-47.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Elementary tasks explain why polynomial decay in n is natural:<br></p>

<ul>
  <li>
<strong>Gaussian mean estimation:</strong> mean‑squared error ∝ σ^2/n, so log‑error is linear in log n with slope −1.<br>
</li>
  <li>
    <p><strong>Nonparametric regression:</strong> covering input domain with bins yields error scaling like n^{-1/d} for data uniformly distributed in d dimensions; effective learning rate decays more slowly as intrinsic dimension increases.<br></p>
  </li>
  <li>
<strong>Mechanistic takeaway:</strong> flexible function classes require exponentially more samples to resolve fine structure in higher intrinsic dimensions, reflected as smaller exponents on log‑log error plots.<br>
</li>
  <li>
<strong>Rationale:</strong> shallow exponents in language modeling can be understood as consequences of high intrinsic dimensionality; inducing strong <strong>inductive biases</strong> or estimating intrinsic dimension can change the empirical exponent.<br>
</li>
  <li>
<strong>Implementation caveat:</strong> intrinsic dimension is hard to estimate robustly, so interpret exponents cautiously and validate across datasets and architectures.<br>
</li>
</ul>

<hr>

<h1 id="observed-empirical-exponents-for-language-related-tasks-are-often-much-smaller-than-simple-parametric-rates-reflecting-high-intrinsic-complexity">Observed empirical exponents for language-related tasks are often much smaller than simple parametric rates, reflecting high intrinsic complexity</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-18-35-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-18-35-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-18-35-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-18-35.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Empirical studies report exponents substantially below classical parametric expectations (examples: ~0.13 for MT, ~0.3 for speech, and ≈0.95 in some LM settings), meaning errors decline much more slowly with dataset size than naive 1/n or 1/√n rates.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> modern language and speech tasks involve highly nonparametric target functions with large effective dimensionality and complex structure, increasing sample complexity.<br>
</li>
  <li>
<strong>Rationale:</strong> shallow empirical exponents imply enormous increases in tokens are needed for modest loss gains, motivating strategies that optimize model architecture and data mixtures rather than naive data accumulation.<br>
</li>
  <li>
<strong>Implementation note:</strong> estimate empirical exponents using a broad range of dataset sizes and carefully control confounders such as model capacity and evaluation protocol.<br>
</li>
</ul>

<hr>

<h1 id="generating-synthetic-data-with-controlled-intrinsic-dimensionality-is-straightforward-but-estimating-real-data-intrinsic-dimension-is-challenging">Generating synthetic data with controlled intrinsic dimensionality is straightforward, but estimating real data intrinsic dimension is challenging</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-20-39-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-20-39-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-20-39-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-20-39.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>To create data with a chosen intrinsic dimension for experiments, specify a function of k latent variables plus noise to produce manifolds of known dimension.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> synthetic manifolds validate predicted n^{-1/d} behavior in nonparametric estimation.<br>
</li>
  <li>
<strong>Practical implication:</strong> synthetic experiments are useful for theory validation, but translating results to complex real data (code, natural text) requires caution because true generative factors and interactions are unknown and noisy.<br>
</li>
  <li>
<strong>Implementation note:</strong> use additional empirical diagnostics when moving from synthetic to real‑world corpora.<br>
</li>
</ul>

<hr>

<h1 id="data-scaling-laws-enable-practical-engineering-decisions-such-as-dataset-composition-optimal-mixing-and-assessing-diminishing-returns-from-repetitions">Data-scaling laws enable practical engineering decisions such as dataset composition, optimal mixing, and assessing diminishing returns from repetitions</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-22-38-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-22-38-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-22-38-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-22-38.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p><strong>Scaling‑law fits</strong> can quantify how dataset composition shifts the <strong>loss offset</strong> without substantially changing the exponent, enabling evaluation of relative data‑quality decisions on smaller models and extrapolation to large regimes.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> fit scaling laws per data source and estimate their contributions to mixed‑data performance, enabling regression‑based optimal mixing strategies for trillion‑token regimes.<br>
</li>
  <li>
<strong>Extension:</strong> scaling laws extend to multi‑epoch training by defining an <strong>effective unique‑token count</strong> that diminishes with repetition, helping decide whether to repeat high‑quality data or add lower‑quality new data.<br>
</li>
  <li>
<strong>Implementation caveats:</strong> data‑selection research is empirically difficult; validate that per‑mixture power‑law assumptions hold in the target regime.<br>
</li>
</ul>

<hr>

<h1 id="when-analyzing-data-scaling-behavior-the-model-size-used-for-evaluation-must-be-large-enough-to-avoid-parameter-limited-saturation">When analyzing data-scaling behavior, the model size used for evaluation must be large enough to avoid parameter-limited saturation</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-25-08-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-25-08-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-25-08-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-25-08.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Data‑scaling experiments assume the <strong>model is not the bottleneck</strong>; therefore experimenters select model sizes sufficiently larger than the task’s effective complexity so loss is dominated by data scarcity rather than model capacity.<br></p>

<ul>
  <li>
<strong>Mechanic:</strong> keep model parameters high and vary only dataset size when fitting data‑scaling exponents.<br>
</li>
  <li>
<strong>Rationale:</strong> if the model is saturated, fitted data‑scaling laws will reflect model limitations rather than true data‑driven gains, invalidating extrapolations.<br>
</li>
  <li>
<strong>Implementation note:</strong> when presenting data‑scaling plots, document the fixed model size and verify that increasing the model further does not substantially change the fitted exponent in the regime of interest.<br>
</li>
</ul>

<hr>

<h1 id="model-scaling-analysis-addresses-trade-offs-among-architectures-optimizers-hyperparameters-and-resource-allocation-for-deployment">Model-scaling analysis addresses trade-offs among architectures, optimizers, hyperparameters, and resource allocation for deployment</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-27-36-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-27-36-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-27-36-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-27-36.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p><strong>Model‑scaling law methodology</strong> evaluates architectures (transformers, LSTMs, state‑space models, gated units, MoE), optimizers (SGD, Adam), and hyperparameters by training families of models across compute budgets and comparing their loss‑versus‑compute trajectories.<br></p>

<ul>
  <li>
<strong>Mechanistic pattern:</strong> curves for different architectures often appear as non‑crossing, parallel‑like lines on log‑log plots, indicating constant‑factor compute efficiency differences and enabling extrapolation that lower‑offset architectures perform better across scales.<br>
</li>
  <li>
<strong>Rationale:</strong> reveals which innovations are worth scaling (e.g., gated linear units, mixture‑of‑experts) and which provide limited benefit when compute is abundant.<br>
</li>
  <li>
<strong>Implementation considerations:</strong> account for parameter types (embeddings vs. non‑embedding parameters) and normalize sparse/conditional parameterizations into equivalent dense‑parameter measures for fair comparisons.<br>
</li>
</ul>

<hr>

<h1 id="optimizer-choice-and-depthwidthaspect-ratio-choices-can-be-evaluated-via-scaling-curves-to-find-scale-robust-hyperparameter-regimes">Optimizer choice and depth/width/aspect-ratio choices can be evaluated via scaling curves to find scale-robust hyperparameter regimes</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-30-38-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-30-38-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-30-38-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-30-38.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Scaling studies comparing optimizers show approximately constant‑factor differences in compute efficiency across dataset sizes, and depth‑versus‑width sweeps reveal broad basins of near‑optimal aspect ratios rather than sharp optima.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> train many models at multiple sizes and plot loss versus compute to test whether slopes and offsets of scaling curves vary across hyperparameter choices; conserved slopes with differing offsets imply small‑scale tuning can transfer to large scale.<br>
</li>
  <li>
<strong>Rationale:</strong> scaling‑law sweeps avoid repeated costly retuning at each scale and identify hyperparameter settings robust across sizes.<br>
</li>
  <li>
<strong>Implementation notes:</strong> sweep multiple sizes (e.g., 50M, 270M, 1.5B) and fit surfaces or envelopes to identify consistent minima.<br>
</li>
</ul>

<hr>

<h1 id="not-all-parameters-are-equivalent-embedding-and-sparsely-activated-parameters-change-scaling-law-behavior-and-require-normalization">Not all parameters are equivalent; embedding and sparsely activated parameters change scaling-law behavior and require normalization</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-33-07-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-33-07-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-33-07-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-33-07.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Certain parameter classes (e.g., <strong>embedding tables</strong>) do not participate in scaling the same way as non‑embedding transformer parameters, producing bends or deviations in naive parameter‑versus‑loss curves.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> counting embeddings as ordinary parameters can distort fitted exponents and offsets, so analyses either exclude embeddings or convert sparse/specialized parameters into an equivalent dense‑parameter metric.<br>
</li>
  <li>
<strong>For conditional/sparse architectures (MoE):</strong> derive an <strong>equivalent dense‑parameter count</strong> to enable fair comparisons and meaningful scaling predictions.<br>
</li>
  <li>
<strong>Implementation implication:</strong> reports should specify which parameter subsets were counted and how sparsity/activation patterns were normalized for cross‑architecture scaling comparisons.<br>
</li>
</ul>

<hr>

<h1 id="batch-size-exhibits-a-critical-threshold-beyond-which-returns-diminish-and-the-critical-batch-size-itself-scales-with-target-loss">Batch size exhibits a critical threshold beyond which returns diminish, and the critical batch size itself scales with target loss</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-36-03-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-36-03-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-36-03-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-36-03.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Increasing batch size up to the <strong>gradient‑noise scale</strong> yields near‑linear wall‑clock/step equivalence (doubling batch size ≈ taking two gradient steps) and is therefore an effective systems optimization; past a <strong>critical batch size</strong>, additional samples per step stop reducing stochastic gradient noise and yield diminishing returns.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> the noise scale defines the regime boundary where optimization transitions from noise‑dominated to curvature‑dominated; the critical batch size can be estimated empirically or modeled theoretically.<br>
</li>
  <li>
<strong>Empirical observation:</strong> the critical batch size tends to decrease as the target loss becomes smaller, so schedules and parallelization should adapt during training.<br>
</li>
  <li>
<strong>Implementation consequences:</strong> plan batch‑size schedules and balance data‑parallel throughput with optimization efficiency; many large training reports adjust batch sizes during runs.<br>
</li>
</ul>

<hr>

<h1 id="learning-rate-optima-vary-with-model-width-under-standard-parameterizations-but-scale-stable-reparameterizations-eg-μpnew-p-can-make-the-optimal-learning-rate-transfer-across-widths">Learning-rate optima vary with model width under standard parameterizations, but scale-stable reparameterizations (e.g., μP/new-p) can make the optimal learning rate transfer across widths</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-39-53-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-39-53-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-39-53-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-39-53.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Under conventional transformer parameterizations the optimal learning rate typically decreases as width increases, producing different tuned optima at different scales and complicating hyperparameter transfer from small to large models.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> reparameterizations that scale initializations and layer‑wise update magnitudes as a function of width (e.g., <strong>μP</strong> or variants) normalize the optimization landscape so a single learning‑rate choice tuned at small scale remains near‑optimal at larger widths.<br>
</li>
  <li>
<strong>Rationale:</strong> scale‑stable parameterizations reduce the need for repeated learning‑rate sweeps across model sizes and simplify large‑scale training planning.<br>
</li>
  <li>
<strong>Implementation caveat:</strong> μP‑like schemes improve transferability but are not a panacea; multiple variants exist (e.g., Meta’s metap) and require empirical validation in each training stack.<br>
</li>
</ul>

<hr>

<h1 id="batch-size-and-learning-rate-interact-via-gradient-noise-considerations-and-their-optimal-pairing-can-change-with-loss-targets-and-modality">Batch size and learning rate interact via gradient-noise considerations, and their optimal pairing can change with loss targets and modality</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-42-39-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-42-39-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-42-39-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-42-39.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Optimal batch‑size choices are linked to <strong>noise scale</strong> and learning‑rate schedules; as training progresses toward lower loss targets, practitioners often increase batch size to reduce gradient noise that would otherwise force smaller learning rates or conservative updates.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> batch size and learning rate affect gradient variance and step size in opposing ways, so their joint tuning is necessary for stable large‑scale training.<br>
</li>
  <li>
<strong>Practical considerations:</strong> modality‑specific behavior (NLP vs. vision) matters and noise‑scale theory gives qualitative guidance rather than a universal prescription.<br>
</li>
  <li>
<strong>Implementation advice:</strong> empirically estimate critical batch sizes and validate learning‑rate transfer or reparameterization choices for the specific model and dataset.<br>
</li>
</ul>

<hr>

<h1 id="log-loss-next-token-prediction-scaling-is-robust-and-predictable-but-downstream-task-scaling-and-capability-emergence-can-be-far-less-predictable">Log-loss (next-token prediction) scaling is robust and predictable, but downstream task scaling and capability emergence can be far less predictable</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-45-10-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-45-10-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-45-10-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-45-10.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p><strong>Cross‑entropy</strong> or negative log‑likelihood scales smoothly and is highly amenable to log‑log linear modeling across architectures and compute levels, explaining why many scaling‑law results focus on perplexity or test loss.<br></p>

<ul>
  <li>
<strong>Mechanism for mismatch:</strong> mapping log‑loss improvements to downstream benchmarks (accuracy, QA, in‑context learning) is often nonlinear and can vary widely across architectures and hyperparameters because task capabilities depend on subtle behaviors not fully captured by perplexity.<br>
</li>
  <li>
<strong>Practical implication:</strong> use direct empirical evaluation on the downstream task of interest rather than assuming that perplexity scaling automatically translates to better task performance.<br>
</li>
</ul>

<hr>

<h1 id="scaling-law-based-design-prescribes-training-small-models-across-orders-of-magnitude-fitting-scaling-relationships-and-extrapolating-optimal-hyperparameters-and-architectures-to-full-scale">Scaling-law-based design prescribes training small models across orders of magnitude, fitting scaling relationships, and extrapolating optimal hyperparameters and architectures to full scale</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-48-36-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-48-36-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-48-36-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-48-36.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Practical recipe for using scaling laws:<br></p>

<ol>
  <li>Run small‑to‑medium scale experiments spanning multiple orders of magnitude in compute.<br>
</li>
  <li>Verify loss versus resource relationships show stable log‑log linearity (or another valid functional form).<br>
</li>
  <li>Fit relationships to extract slopes and offsets.<br>
</li>
  <li>Use fits to choose model size, data budget, batch size, and hyperparameters for a single large‑scale run.<br>
</li>
</ol>

<ul>
  <li>
<strong>Mechanism:</strong> relies on conserved slopes (non‑crossing curves) so small‑scale minima and offsets transfer to larger scales.<br>
</li>
  <li>
<strong>Rationale:</strong> reduces risk and cost compared to brute‑force large‑scale hyperparameter searches.<br>
</li>
  <li>
<strong>Caveats:</strong> some parameters (e.g., learning rate) may not transfer without reparameterization.<br>
</li>
  <li>
<strong>Best practices:</strong> span a broad compute range, report fit uncertainty, and validate extrapolations with a limited number of larger intermediate runs when feasible.<br>
</li>
</ul>

<hr>

<h1 id="joint-datamodel-scaling-laws-iso-flop-trade-offs-describe-how-loss-decomposes-into-data-dependent-and-model-dependent-components-and-enable-optimal-compute-allocation">Joint data–model scaling laws (iso-flop trade-offs) describe how loss decomposes into data-dependent and model-dependent components and enable optimal compute allocation</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-52-28-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-52-28-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-52-28-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-52-28.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p><strong>Joint scaling models</strong> posit additive or multiplicative decompositions of error into terms that decay polynomially with data (n) and model size (m), plus irreducible error, often written as Loss(n,m) ≈ c_n n^{-α_n} + c_m m^{-α_m} + c_0.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> fit such a two‑variable surface across grids of (n,m) to compute <strong>iso‑flop curves</strong> that show optimal parameter/token trade‑offs for a fixed compute budget.<br>
</li>
  <li>
<strong>Rationale:</strong> answer whether to allocate compute to more parameters or more data and derive prescriptions (e.g., tokens‑per‑parameter ratios) that minimize loss for fixed flops.<br>
</li>
  <li>
<strong>Implementation notes:</strong> perform careful surface fitting, account for learning‑rate and schedule interactions, and validate extrapolations with held‑out larger‑scale runs.<br>
</li>
</ul>

<hr>

<h1 id="the-chinchilla-analysis-operationalized-iso-flop-optimization-and-indicated-an-approximately-20-tokens-per-parameter-budget-under-its-assumptions">The Chinchilla analysis operationalized iso-flop optimization and indicated an approximately 20 tokens-per-parameter budget under its assumptions</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-55-32-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-55-32-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-55-32-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-55-32.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Chinchilla used three empirical methods to infer the optimal <strong>token‑to‑parameter ratio</strong> for minimizing loss at fixed training flops and found a consistent recommendation near ~20 tokens per parameter under their training protocol and schedules.<br></p>

<ul>
  <li>
<strong>Mechanisms used:</strong> lower envelope of performance across models, isoflop minima extraction via quadratic fits per compute slice, and direct joint functional form fitting; the first two produced similar coefficients while the third required careful regression handling.<br>
</li>
  <li>
<strong>Rationale:</strong> the tokens‑per‑parameter guideline provided a practical balance between parameter count and dataset size for a given compute budget and guided many subsequent training budgets.<br>
</li>
  <li>
<strong>Implementation caveat:</strong> the precise optimal ratio depends on learning‑rate schedule, optimization details, and evaluation protocol, so reproducing the exact number requires matching training recipes.<br>
</li>
</ul>

<hr>

<h1 id="method-1-minimum-envelope-finds-the-optimal-model-size-and-data-allocation-by-taking-the-lower-envelope-across-many-training-curves">Method 1 (minimum-envelope) finds the optimal model-size and data allocation by taking the lower envelope across many training curves</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-57-25-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-57-25-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-57-25-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-57-25.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>The <strong>minimum‑envelope method</strong> overlays training curves for models of different parameter counts across compute budgets and selects the lower envelope of achievable loss for each compute level.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> read off the parameter count and token count at the envelope to get an empirical optimal token‑to‑parameter ratio; the approach is nonparametric and leverages the smooth curve formed by observed optima.<br>
</li>
  <li>
<strong>Rationale:</strong> makes minimal modeling assumptions and directly uses observed optima, making it robust when grid coverage is sufficient.<br>
</li>
  <li>
<strong>Implementation requirements:</strong> train a dense grid of model sizes and checkpoints across compute so the envelope is well‑resolved; use interpolation or local quadratic fits to reduce noise when identifying minima.<br>
</li>
</ul>

<hr>

<h1 id="method-2-isoflop-analysis-finds-the-optimal-parameterdata-trade-off-by-minimizing-loss-along-fixed-flop-slices-and-reading-out-the-minima">Method 2 (isoflop analysis) finds the optimal parameter/data trade-off by minimizing loss along fixed-flop slices and reading out the minima</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/00-59-33-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/00-59-33-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/00-59-33-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/00-59-33.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p><strong>Isoflop analysis</strong> fixes total compute (flops) and, for each compute level, sweeps model sizes and corresponding token counts to find the configuration that minimizes loss within that budget.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> implement by fitting local quadratics to loss‑versus‑parameter curves at each isoflop and extracting minima to reduce measurement noise.<br>
</li>
  <li>
<strong>Rationale:</strong> directly answers how to allocate a given compute budget between model size and dataset size.<br>
</li>
  <li>
<strong>Implementation notes:</strong> require careful curve smoothing and validation across multiple compute levels to ensure minima form a stable power‑law curve amenable to extrapolation.<br>
</li>
</ul>

<hr>

<h1 id="method-3-direct-joint-functional-fitting-fits-a-parametric-two-variable-surface-to-observed-runs-but-requires-careful-regression-to-avoid-biased-coefficients">Method 3 (direct joint functional fitting) fits a parametric two-variable surface to observed runs but requires careful regression to avoid biased coefficients</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/01-01-03-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/01-01-03-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/01-01-03-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/01-01-03.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>An alternative approach fits a global parametric form Loss(n,m)=c_n n^{-α_n}+c_m m^{-α_m}+c_0 to all observed runs and extracts optimal trade‑offs from the fitted surface.<br></p>

<ul>
  <li>
<strong>Mechanistic risk:</strong> sensitive to regression setup and residual structure; non‑zero‑mean residuals or heteroscedasticity can bias estimated exponents and conflict with envelope or isoflop methods.<br>
</li>
  <li>
<strong>Empirical lesson:</strong> documented replication found that correcting residual issues reconciled the global fit with envelope/isoflop methods, highlighting the importance of statistically careful fitting.<br>
</li>
  <li>
<strong>Implementation takeaway:</strong> inspect residuals, consider weighted regression, and validate global fits against lower‑envelope or isoflop minima to ensure consistent conclusions.<br>
</li>
</ul>

<hr>

<h1 id="inference-cost-and-deployment-considerations-have-shifted-preferred-training-regimes-toward-much-higher-tokens-per-parameter-ratios">Inference cost and deployment considerations have shifted preferred training regimes toward much higher tokens-per-parameter ratios</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/01-02-01-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/01-02-01-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/01-02-01-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/01-02-01.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>As models became deployed products with recurring inference costs, the operational trade‑off shifted: pay more one‑time training cost (increased tokens per parameter) to produce <strong>smaller models</strong> that are cheaper to serve at inference time.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> increasing tokens per parameter while reducing parameter counts lowers steady‑state inference FLOPs and monetary serving cost even if training cost stays similar or increases modestly.<br>
</li>
  <li>
<strong>Historical trend:</strong> GPT‑3 used smaller token/parameter ratios while Chinchilla and later models pushed toward ~20 tokens/parameter; recent models experiment with even larger token budgets to prioritize compact inference.<br>
</li>
  <li>
<strong>Implementation implication:</strong> product teams should treat tokens‑per‑parameter as a tunable hyperparameter driven by the relative costs of training versus inference and by service‑level targets.<br>
</li>
</ul>

<hr>

<h1 id="scaling-law-methodologies-generalize-to-different-generative-architectures-eg-diffusion-text-models-and-often-reproduce-similar-iso-flop-minima-separated-by-constant-offsets">Scaling-law methodologies generalize to different generative architectures (e.g., diffusion text models) and often reproduce similar iso-flop minima separated by constant offsets</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/01-03-23-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/01-03-23-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/01-03-23-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/01-03-23.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>When applied to novel modeling paradigms (e.g., <strong>text diffusion models</strong>), the same empirical playbook (isoslop/isoflop analyses) often produces predictable scaling behavior with curves that mirror autoregressive results up to constant offsets.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> training grids for alternative architectures and plotting minimum loss envelopes often reveals parallel power‑law behavior, indicating scaling phenomena are not idiosyncratic to one objective or decoder.<br>
</li>
  <li>
<strong>Rationale:</strong> cross‑model reproducibility supports using scaling‑law analysis as a general engineering tool when exploring new model families, subject to careful experimental control.<br>
</li>
  <li>
<strong>Implementation note:</strong> confirm offset magnitudes and that the productive regime exists for the new architecture before extrapolating to extreme scales.<br>
</li>
</ul>

<hr>

<h1 id="log-linear-scaling-across-data-parameters-and-compute-provides-a-unifying-empirical-foundation-for-many-practical-model-design-and-resource-allocation-decisions">Log-linear scaling across data, parameters, and compute provides a unifying empirical foundation for many practical model-design and resource-allocation decisions</h1>

<div class="row mt-3 text-center">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cs336-2025/frames/lec09/01-04-35-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cs336-2025/frames/lec09/01-04-35-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cs336-2025/frames/lec09/01-04-35-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/cs336-2025/frames/lec09/01-04-35.jpg" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

    </div>
</div>
<p>Power‑law (log‑log linear) relationships often hold across multiple axes — dataset size, parameter count, compute — enabling unified analyses for architecture selection, hyperparameter transfer, iso‑flop optimization, and batch/learning‑rate scheduling.<br></p>

<ul>
  <li>
<strong>Mechanism:</strong> these empirical regularities permit dimensionality reduction of design choices into simple curves or surfaces that teams can fit on small‑to‑moderate experiments and extrapolate to production scales.<br>
</li>
  <li>
<strong>Practical impact:</strong> guidance on tokens‑per‑parameter ratios, when to prefer more data versus more parameters, and how to design scale‑stable parameterizations for optimizer transfer.<br>
</li>
  <li>
<strong>Caveats:</strong> validate scaling assumptions for downstream tasks, account for training‑schedule interactions, and quantify fit uncertainty.<br>
</li>
  <li>
<strong>Summary implication:</strong> when properly validated, scaling laws materially reduce the risk and cost of building large‑scale generative models by turning extensive empirical sweeps into concise, actionable extrapolations.<br>
</li>
</ul>

<hr>


    </div>
  </article>


  
    
    <br>
    <hr>
    <br>
    <ul class="list-disc pl-8"></ul>

    <!-- Adds related posts to the end of an article -->
    <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2>
    <p class="mb-2">Here are some more articles you might like to read next:</p>
  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/mit-6s184-lec06/">MIT 6.S184 - Lecture 6 - Diffusion for Protein Generation</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/mit-6s184-lec05/">MIT 6.S184 - Lecture 5 - Diffusion for Robotics</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/mit-6s184-lec04/">MIT 6.S184 - Lecture 4 - Building an Image Generator</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/mit-6s184-lec03/">MIT 6.S184 - Lecture 3 - Training Flow and Diffusion Models</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/mit-6s184-lec02/">MIT 6.S184 - Lecture 2 -  Constructing a Training Target</a>
  </li>

</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2025 Tuan-Anh  Bui. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script>
  <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script>
  <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7KGSMMS9MS"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-7KGSMMS9MS');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

    
  </body>
</html>
